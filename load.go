package cache

import (
	"context"
	"go-eCache/internal/utils"
	"reflect"
	"time"
)

const (
	// loadDefaultOnErrExpiration will be used if user did not set on err expiration time in the option
	loadDefaultOnErrExpiration = 3000 * time.Millisecond
)

// loadResult is the result to pass between layers of caches for Load and LoadMany
type loadResult struct {
	dataBytes []byte      // dataBytes is the bytes generated by codec handler
	data      interface{} // data is the original data without marshaling
	err       error
	header    metaHeader
}

// loadHandleKeys loads toHandleKeys (to-update-keys or missing-keys) and set the load result into cache.
// Besides, if users adopt AcrossInstanceSignal, we will acquire, maintain, and release the distributed lock here.
func loadHandleKeys(ctx context.Context, inner *cacheWrapperInner, keys []string, receiverMap map[string]interface{}, loader DataLoader, expire time.Duration, curManufacturerHandler manufacturerHandler, curCodecHandler codecHandler, option cacheOperationOptions) map[string]loadResult {
	loadResultMap, waitingAcrossInstanceKeys, randValue := handleDataLoaderLayerForInner(ctx, inner, keys, loader, expire, curManufacturerHandler, curCodecHandler, option)
	setManyErr := setManyForLoad(ctx, inner, loadResultMap, inner.codecHandler, option)
	if setManyErr != nil {
		loadResultMap = genErrResultsFromMap(loadResultMap, setManyErr)
	}
	if curManufacturerHandler.strategy == AcrossInstanceSignal {
		releaseDlock(ctx, inner, loadResultMap, randValue)
		loadResultMap = waitAcrossInstance(ctx, inner, waitingAcrossInstanceKeys, receiverMap, loadResultMap, curManufacturerHandler.acrossInstanceSignalConfig.retryInterval, curCodecHandler, option)
	}
	return loadResultMap
}

// waitAcrossInstance keeps (re)trying to get the waitingAcrossInstanceKeys, the missing keys which are (being) loaded by another instance.
// This function is applicable only when stampede mitigation strategy is `AcrossInstanceSignal`.
//
// If some keys detect dlock loss and fail getting values, they will be filled with nil data and errDlockLoss error.
// If some keys remain failure in getting values by timeout, they will be filled with nil data and errContextTimeout error.
func waitAcrossInstance(ctx context.Context, inner *cacheWrapperInner, waitingAcrossInstanceKeys []string, receiverMap map[string]interface{}, loadResultMap map[string]loadResult, retryInterval time.Duration, curCodecHandler codecHandler, option cacheOperationOptions) map[string]loadResult {
	if len(waitingAcrossInstanceKeys) == 0 {
		return loadResultMap
	}
	missingKeys, _, resultMap, getManyErr := getManyForLoad(ctx, inner, waitingAcrossInstanceKeys, receiverMap, curCodecHandler, option)
	if getManyErr != nil {
		resultMap = genErrResults(waitingAcrossInstanceKeys, getManyErr)
	}

	if len(missingKeys) > 0 {
		var retryResultMap map[string]loadResult
		var lostDockKeys, preRoundMissingKeys []string

		dlockMap := getDlockMap(ctx, inner, missingKeys)
		ticker := time.NewTicker(retryInterval)
		defer ticker.Stop()
		endTicker := false // to force exit the loop, `break` alone does not work

		// retry to get data if failed
		for !endTicker {
			select {
			case <-ctx.Done():
				resultMap = fillMissingWaitingKeys(missingKeys, resultMap, errContextTimeout)
				endTicker = true
			case <-ticker.C:
				resultMap = fillMissingWaitingKeys(lostDockKeys, resultMap, errDlockLoss)
				preRoundMissingKeys, _, retryResultMap, getManyErr = getManyForLoad(ctx, inner, missingKeys, receiverMap, curCodecHandler, option)
				if getManyErr != nil {
					retryResultMap = genErrResults(missingKeys, getManyErr)
				}
				for key, value := range retryResultMap {
					resultMap[key] = value
				}
				missingKeys = preRoundMissingKeys
				// there is no duplicated element in waitingAcrossInstanceKeys
				if len(waitingAcrossInstanceKeys) == len(resultMap) {
					endTicker = true
					break
				}
				lostDockKeys = getLostDlockKeys(ctx, inner, missingKeys, dlockMap)
			}
		}
	}

	for key, value := range resultMap {
		loadResultMap[key] = value
	}
	return loadResultMap
}

func fillMissingWaitingKeys(lostDockKeys []string, resultMap map[string]loadResult, err error) map[string]loadResult {
	for _, toFillKey := range lostDockKeys {
		resultMap[toFillKey] = loadResult{nil, nil, err, metaHeader{}}
	}
	return resultMap
}

func getManyForLoad(ctx context.Context, inner *cacheWrapperInner, keys []string, receiverMap map[string]interface{}, codecHandler codecHandler, option cacheOperationOptions) (missingKeys, toUpdateKeys []string, successKeyResultMap map[string]loadResult, err error) {

	fixedKeys, requestSize := inner.getFixedKeys(ctx, keys)

	stats := &RequestStats{
		CacheName:      inner.name,
		CacheType:      inner.cacheType.String(),
		CacheOperation: cmdGetMany,
		TotalKeyCount:  len(fixedKeys),
		RequestSize:    requestSize,
		hostName:       inner.cacheHostName,
		req:            fixedKeys,
	}
	requestStatsDecorator(ctx, stats, func() error {
		values, innerCacheErr := inner.cache.getMany(ctx, fixedKeys...)
		if innerCacheErr != nil {
			err = innerCacheErr
			return err
		}
		successKeyResultMap = make(map[string]loadResult)
		respMap := make(map[string]interface{}) // respMap is only be used for the statCollector
		now := time.Now()
		responseSize := 0
		successKeyCount := 0
		for idx, val := range values {
			curKey := keys[idx]
			respMap[curKey] = nil
			responseSize += inner.getEncodedDataSize(val)
			if val == nil {
				missingKeys = append(missingKeys, curKey)
				continue
			}
			successKeyCount++
			data, header, decodeErr := inner.decode(values[idx], false)
			if decodeErr != nil {
				missingKeys = append(missingKeys, curKey)
				continue
			}

			// check skipCodec option and cache type
			if option.skipCodec {
				if inner.cacheType == inMemory {
					successKeyResultMap[curKey] = loadResult{nil, data, nil, header}
				} else {
					if receiverMap[curKey] == nil {
						err = errNilReceiver
						return err
					}
					receiver := reflect.New(reflect.TypeOf(receiverMap[curKey]).Elem()).Interface()
					dataBytes, _ := data.([]byte)
					unmarshalErr := codecHandler.unmarshal(dataBytes, receiver, option.codecType, option.customCodec)
					if unmarshalErr != nil {
						missingKeys = append(missingKeys, curKey)
						continue
					}
					successKeyResultMap[curKey] = loadResult{dataBytes, receiver, nil, header}
				}
			} else {
				dataBytes, _ := data.([]byte)
				successKeyResultMap[curKey] = loadResult{dataBytes, nil, nil, header}
			}
			respMap[curKey] = data
			if needUpdate(now, header) {
				toUpdateKeys = append(toUpdateKeys, curKey)
			}
		}

		stats.SuccessKeyCount = successKeyCount
		stats.ResponseSize = responseSize
		stats.resp = respMap

		return err
	})
	return missingKeys, toUpdateKeys, successKeyResultMap, err
}

func setManyForLoad(ctx context.Context, inner *cacheWrapperInner, loadResultMap map[string]loadResult, codecHandler codecHandler, option cacheOperationOptions) error {
	if len(loadResultMap) == 0 {
		return nil
	}
	if inner.isDisabledCtxOrConfig(ctx) {
		return nil
	}

	stats := &RequestStats{
		CacheName:      inner.name,
		CacheType:      inner.cacheType.String(),
		CacheOperation: cmdSetMany,
		TotalKeyCount:  len(loadResultMap),
		hostName:       inner.cacheHostName,
	}
	var err error
	requestStatsDecorator(ctx, stats, func() error {
		valMap := make(map[string]interface{}, len(loadResultMap))
		expMap := make(map[string]time.Duration, len(loadResultMap)) // fully relies on expMap for expiration
		stats.req = valMap
		requestSize := 0
		for key, loadResult := range loadResultMap {
			if loadResult.dataBytes == nil && loadResult.data == nil {
				continue
			}
			expire := getHardExpiration(loadResult.header.HardTimeoutTs)
			// already hard expired, no need to set outdated value
			if expire == 0 {
				continue
			}
			expire = inner.translateExpire(ctx, expire) // each layer may have different maxExpiration and defaultExpiration
			option.softTimeoutTs = loadResult.header.SoftTimeoutTs
			option.hardTimeoutTs = loadResult.header.HardTimeoutTs
			option.skipEncodeDecode = false

			var encodedData interface{}
			var encodeErr error
			if option.skipCodec {
				if inner.cacheType == inMemory {
					data := utils.GetValue(loadResult.data)
					encodedData, encodeErr = inner.encode(data, &option)
				} else {
					if loadResult.dataBytes != nil {
						encodedData, encodeErr = inner.encode(loadResult.dataBytes, &option)
					} else {
						dataBytes, marshalErr := codecHandler.marshal(loadResult.data, option.codecType, option.customCodec)
						if marshalErr != nil {
							err = marshalErr
							continue
						}
						encodedData, encodeErr = inner.encode(dataBytes, &option)
					}
				}
			} else {
				encodedData, encodeErr = inner.encode(loadResult.dataBytes, &option)
			}

			if encodeErr != nil {
				err = encodeErr
				continue
			}

			fixedKey := inner.getFixedKey(ctx, key)
			valMap[fixedKey] = encodedData
			expMap[fixedKey] = expire
			requestSize += len(fixedKey) + inner.getEncodedDataSize(encodedData)
		}
		stats.RequestSize = requestSize
		if len(valMap) == 0 {
			stats.skipOperationLogs = err == nil
			return err
		}
		setManyErr := inner.cache.setMany(ctx, valMap, unsetExpiration, withNoReply(option.noReply), withExpirationMap(expMap), withWaitRistretto(option.waitRistretto))
		if setManyErr != nil {
			err = setManyErr
		}

		return err
	})
	return err
}

// handleDataLoaderLayerForInner handles the data-loading at the cacheWrapperInner. If users adopt AcrossInstanceSignal, distributed lock is set and maintained here at the cacheWrapperInner.
// Besides, when using multilayer cache, dataloading logics are handled in the cacheWrapperInner of the last cache layer.
func handleDataLoaderLayerForInner(ctx context.Context, inner *cacheWrapperInner, keys []string, loader DataLoader, expire time.Duration, curManufacturerHandler manufacturerHandler, curCodecHandler codecHandler, option cacheOperationOptions) (map[string]loadResult, []string, []byte) {
	loadResultMap := make(map[string]loadResult)
	var toHandleKeys, waitingAcrossInstanceKeys []string
	var randValue []byte

	if curManufacturerHandler.strategy == AcrossInstanceSignal {
		finishDataLoadSignal := make(chan struct{}, 1)
		defer close(finishDataLoadSignal)

		randValue = randDlockValue()
		dlockUnitExpire := curManufacturerHandler.acrossInstanceSignalConfig.dlockUnitExpiration
		var err error
		toHandleKeys, waitingAcrossInstanceKeys, err = reclassifyToHandleKeys(ctx, inner, keys, randValue, dlockUnitExpire)
		if err != nil {
			return genErrResults(keys, err), waitingAcrossInstanceKeys, randValue
		}
		if len(toHandleKeys) == 0 {
			return loadResultMap, waitingAcrossInstanceKeys, randValue
		}
		go func() {
			// ticker more times than an expiration for the dlock key
			ticker := time.NewTicker(dlockUnitExpire >> 2)
			defer ticker.Stop()

			for {
				select { // in case the context canceled or reach the deadline
				case <-ctx.Done():
					return
				case <-finishDataLoadSignal:
					return
				case <-ticker.C:
					extendDlock(ctx, inner, toHandleKeys, randValue, dlockUnitExpire)
				}
			}
		}()
		loadResultMap = handleDataLoaderLayer(ctx, inner, toHandleKeys, loader, expire, curCodecHandler, option)
		finishDataLoadSignal <- struct{}{}
	} else {
		loadResultMap = handleDataLoaderLayer(ctx, inner, keys, loader, expire, curCodecHandler, option)
	}

	return loadResultMap, waitingAcrossInstanceKeys, randValue
}

// handleDataLoaderLayer handles the data-loading for keys and returns the loaded results. It will call DataLoader provided by clients.
//
// It returns `loadResult` that incorporates marshaled data bytes, un-marshaled data, error, and meta-header (soft/hard time out included).
// The length of loadResult is exactly the SAME as length of input keys.
func handleDataLoaderLayer(ctx context.Context, inner *cacheWrapperInner, keys []string, loader DataLoader, expire time.Duration, codecHandler codecHandler, option cacheOperationOptions) (loadResultMap map[string]loadResult) {
	loadResultMap = make(map[string]loadResult, len(keys))

	if loader == nil {
		// no loader means the request is for getMany, simply return ErrCacheMiss
		loadResultMap = genErrResults(keys, ErrCacheMiss)
		return
	}
	defer func() {
		// In this function, it may encounter panic issue from data loader.
		if r := recover(); r != nil {
			loadResultMap = genErrResults(keys, errDataLoaderPanic)
		}
	}()

	dataList, err := loader(ctx, keys)
	if len(dataList) != len(keys) {
		if err != nil {
			loadResultMap = genErrResults(keys, err)
		} else {
			loadResultMap = genErrResults(keys, errDataLoaderNotReturnAllData)
		}
		return
	}

	var onErr bool
	if err != nil {
		onErr = true
	}

	now := time.Now()
	for idx, dataFromLoader := range dataList {
		curKey := keys[idx]
		softTimeoutTs := genSoftTimeoutTs(now, option.softExpiration)
		hardTimeoutTs := genHardTimeoutTs(inner, curKey, expire, now, option, onErr)
		header := metaHeader{SoftTimeoutTs: softTimeoutTs, HardTimeoutTs: hardTimeoutTs}
		if dataFromLoader == nil {
			loadResultMap[curKey] = loadResult{nil, nil, err, metaHeader{}}
			continue
		}
		if option.skipCodec {
			// no need to get bytes for skipCodec here, we will marshal later in setManyForLoad
			loadResultMap[curKey] = loadResult{nil, dataFromLoader, err, header}
		} else {
			dataBytes, codecErr := codecHandler.marshal(dataFromLoader, option.codecType, option.customCodec)
			if codecErr != nil {
				loadResultMap[curKey] = loadResult{nil, nil, codecErr, metaHeader{}}
				continue
			}
			loadResultMap[curKey] = loadResult{dataBytes, dataFromLoader, err, header}
		}
	}
	return loadResultMap
}

func setLoadResultsToReceiverMap(resultMap map[string]loadResult, receiverMap map[string]interface{}, codecHandler codecHandler, option cacheOperationOptions) error {
	for key, result := range resultMap {
		if err := setLoadResultToReceiver(key, result, receiverMap, codecHandler, option); err != nil {
			return err
		}
	}
	return nil
}

func setLoadResultToReceiver(key string, result loadResult, receiverMap map[string]interface{}, codecHandler codecHandler, option cacheOperationOptions) (err error) {
	if result.err == nil {
		if result.dataBytes == nil && result.data == nil {
			handleMissingKey(option.nonExistKeyStrategy, receiverMap, key)
			return
		}

		if receiverMap[key] == nil {
			return errNilReceiver
		}

		if option.skipCodec {
			data := utils.GetValue(result.data)
			err = utils.SetValue(data, receiverMap[key])
		} else {
			err = codecHandler.unmarshal(result.dataBytes, receiverMap[key], option.codecType, option.customCodec)
		}
	} else {
		if result.err == ErrCacheMiss {
			handleMissingKey(option.nonExistKeyStrategy, receiverMap, key)
			return
		}
		err = result.err
	}

	return err
}

func genHardTimeoutTs(inner *cacheWrapperInner, key string, expire time.Duration, now time.Time, option cacheOperationOptions, onErr bool) int64 {
	var hardTimeoutTs int64
	curTs := now.Unix()
	// use more specific expiration from option.expirationMap
	if expireFromExpMap, ok := option.expirationMap[key]; ok {
		expire = expireFromExpMap
	}
	if onErr {
		expire = option.onErrExpiration
	}
	switch expire {
	case DefaultExpiration:
		if inner.defaultExpiration == NoExpiration {
			hardTimeoutTs = hardTimeoutForeverIndicator
		} else {
			hardTimeoutTs = curTs + int64(inner.defaultExpiration.Seconds())
		}
	case NoExpiration:
		hardTimeoutTs = hardTimeoutForeverIndicator
	default:
		hardTimeoutTs = curTs + int64(expire.Seconds())
	}
	return hardTimeoutTs
}

func genSoftTimeoutTs(now time.Time, duration time.Duration) int64 {
	var softTimeoutTs int64
	curTs := now.Unix()
	if duration > 0 {
		softTimeoutTs = curTs + int64(duration.Seconds())
	}
	return softTimeoutTs
}

func genHardTimeoutDurationForLayer(expire time.Duration, cacheIdx int, option cacheOperationOptions) time.Duration {
	tempHardExpireDuration := expire
	if len(option.hardExpirationMultiLayer) > cacheIdx {
		tempHardExpireDuration = option.hardExpirationMultiLayer[cacheIdx]
	}
	return tempHardExpireDuration
}

func genSoftTimeoutDurationForLayer(cacheIdx int, option cacheOperationOptions) time.Duration {
	tempSoftExpireDuration := option.softExpiration
	if len(option.softExpirationMultiLayer) > cacheIdx {
		tempSoftExpireDuration = option.softExpirationMultiLayer[cacheIdx]
	}
	return tempSoftExpireDuration
}

func genErrResults(keys []string, err error) map[string]loadResult {
	newResults := make(map[string]loadResult)
	for _, key := range keys {
		newResults[key] = loadResult{nil, nil, err, metaHeader{}}
	}
	return newResults
}

func genErrResultsFromMap(loadResultMap map[string]loadResult, err error) map[string]loadResult {
	for key := range loadResultMap {
		loadResultMap[key] = loadResult{nil, nil, err, metaHeader{}}
	}
	return loadResultMap
}

func needUpdate(now time.Time, header metaHeader) bool {
	return 0 < header.SoftTimeoutTs && header.SoftTimeoutTs <= now.Unix()
}

func getHardExpiration(hardTimeoutTs int64) time.Duration {
	if hardTimeoutTs == hardTimeoutForeverIndicator {
		return NoExpiration
	}
	unixTime := time.Unix(hardTimeoutTs, 0)
	hardExpiration := time.Until(unixTime)
	if hardExpiration <= 0 {
		// return zero value to indicate not set hardExpiration
		return time.Duration(0)
	}
	return hardExpiration
}
